# FFXIV战斗数据API 使用指南

## 🚀 快速开始

### 第一步：环境准备

1. **确保Python环境**
   - Python 3.8 或更高版本
   - 推荐使用虚拟环境

```bash
# 创建虚拟环境
python -m venv ffxiv_api_env

# 激活虚拟环境 (Windows)
ffxiv_api_env\Scripts\activate

# 激活虚拟环境 (Linux/Mac)
source ffxiv_api_env/bin/activate
```

2. **安装依赖**
```bash
# 进入项目目录
cd e:\code\myact\FFXIV_ACT_Plugin\api_design

# 安装所需包
pip install -r requirements.txt
```

### 第二步：启动API服务

```bash
# 方式1：直接运行
python main.py

# 方式2：使用uvicorn
uvicorn main:app --host 0.0.0.0 --port 8000 --reload

# 方式3：后台运行
nohup python main.py &
```

服务启动后，您会看到：
```
INFO:     Started server process [12345]
INFO:     Waiting for application startup.
INFO:     FFXIV Combat Parser 初始化成功
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000
```

### 第三步：验证服务

打开浏览器访问：
- **API文档**: http://localhost:8000/docs
- **健康检查**: http://localhost:8000/health
- **API状态**: http://localhost:8000/api/v1/status

## 📊 基本使用示例

### 1. 查看API文档
访问 http://localhost:8000/docs 查看完整的API接口文档，包括：
- 所有接口列表
- 参数说明
- 响应格式
- 在线测试功能

### 2. Python客户端使用

```python
import requests
import json
import websocket
import threading

# API基础地址
API_BASE = "http://localhost:8000"

# 获取当前战斗信息
def get_current_combat():
    response = requests.get(f"{API_BASE}/api/v1/combat/current")
    if response.status_code == 200:
        return response.json()
    return None

# 获取实时DPS统计
def get_live_stats():
    response = requests.get(f"{API_BASE}/api/v1/combat/live/stats")
    return response.json()

# 获取最近的战斗事件
def get_recent_events(limit=20):
    response = requests.get(f"{API_BASE}/api/v1/combat/live/events?limit={limit}")
    return response.json()

# 搜索技能
def search_actions(keyword):
    response = requests.get(f"{API_BASE}/api/v1/search/actions?keyword={keyword}")
    return response.json()

# WebSocket监听实时数据
def listen_live_events():
    def on_message(ws, message):
        data = json.loads(message)
        print(f"收到事件: {data['type']}")
        
        if data['type'] == 'damage':
            print(f"  {data['source_name']} 对 {data['target_name']} 造成 {data['damage']} 伤害")
        elif data['type'] == 'heal':
            print(f"  {data['source_name']} 治疗了 {data['target_name']} {data['heal_amount']} 点")

    def on_error(ws, error):
        print(f"WebSocket错误: {error}")

    def on_close(ws, close_status_code, close_msg):
        print("WebSocket连接关闭")

    ws = websocket.WebSocketApp("ws://localhost:8000/ws/live",
                                on_message=on_message,
                                on_error=on_error,
                                on_close=on_close)
    ws.run_forever()

# 使用示例
if __name__ == "__main__":
    # 获取当前战斗
    combat = get_current_combat()
    print(f"当前战斗: {combat}")
    
    # 获取实时统计
    stats = get_live_stats()
    print(f"实时统计: {stats}")
    
    # 搜索技能
    fire_skills = search_actions("fire")
    print(f"火系技能: {fire_skills}")
    
    # 启动WebSocket监听 (在单独线程中)
    ws_thread = threading.Thread(target=listen_live_events)
    ws_thread.daemon = True
    ws_thread.start()
    
    # 主程序继续运行...
    input("按回车键退出...")
```

### 3. JavaScript/Web使用

```html
<!DOCTYPE html>
<html>
<head>
    <title>FFXIV数据监控</title>
</head>
<body>
    <div id="stats"></div>
    <div id="events"></div>

    <script>
        // 获取实时统计
        async function fetchStats() {
            try {
                const response = await fetch('/api/v1/combat/live/stats');
                const stats = await response.json();
                
                document.getElementById('stats').innerHTML = 
                    '<h3>实时DPS统计</h3>' +
                    Object.entries(stats).map(([player, data]) => 
                        `<p>${player}: ${Math.round(data.dps || 0)} DPS</p>`
                    ).join('');
            } catch (error) {
                console.error('获取统计失败:', error);
            }
        }

        // WebSocket实时事件
        const ws = new WebSocket('ws://localhost:8000/ws/live');
        const eventsList = [];

        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            eventsList.unshift(data);
            eventsList.splice(10); // 只保留最近10个事件
            
            updateEventsDisplay();
        };

        function updateEventsDisplay() {
            const eventsHtml = eventsList.map(event => {
                if (event.type === 'damage') {
                    return `<p style="color: red;">${event.source_name} → ${event.target_name}: ${event.damage} 伤害</p>`;
                } else if (event.type === 'heal') {
                    return `<p style="color: green;">${event.source_name} → ${event.target_name}: ${event.heal_amount} 治疗</p>`;
                }
                return '';
            }).join('');
            
            document.getElementById('events').innerHTML = '<h3>实时事件</h3>' + eventsHtml;
        }

        // 定期更新统计
        setInterval(fetchStats, 1000);
        fetchStats(); // 初始加载
    </script>
</body>
</html>
```

## 🎮 实际应用场景

### 1. 团队DPS监控面板

```python
import tkinter as tk
from tkinter import ttk
import requests
import threading
import time

class DPSMonitor:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("FFXIV DPS监控")
        self.root.geometry("600x400")
        
        # 创建表格
        self.tree = ttk.Treeview(self.root, columns=('DPS', 'Damage', 'Hits'), show='tree headings')
        self.tree.heading('#0', text='玩家名称')
        self.tree.heading('DPS', text='DPS')
        self.tree.heading('Damage', text='总伤害')
        self.tree.heading('Hits', text='命中次数')
        self.tree.pack(fill=tk.BOTH, expand=True)
        
        # 启动数据更新线程
        self.update_thread = threading.Thread(target=self.update_data, daemon=True)
        self.update_thread.start()
    
    def update_data(self):
        while True:
            try:
                response = requests.get("http://localhost:8000/api/v1/combat/live/stats")
                if response.status_code == 200:
                    stats = response.json()
                    self.root.after(0, self.update_ui, stats)
            except Exception as e:
                print(f"更新数据失败: {e}")
            
            time.sleep(1)
    
    def update_ui(self, stats):
        # 清空现有数据
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        # 添加新数据，按DPS排序
        sorted_stats = sorted(stats.items(), key=lambda x: x[1].get('dps', 0), reverse=True)
        
        for player_id, data in sorted_stats:
            self.tree.insert('', 'end', text=player_id, values=(
                f"{data.get('dps', 0):.1f}",
                f"{data.get('total_damage', 0):,}",
                f"{data.get('hit_count', 0)}"
            ))
    
    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    monitor = DPSMonitor()
    monitor.run()
```

### 2. Discord机器人集成

```python
import discord
from discord.ext import commands, tasks
import aiohttp
import asyncio

class FFXIVBot(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix='!', intents=discord.Intents.default())
        self.api_base = "http://localhost:8000"
        
    async def setup_hook(self):
        self.combat_monitor.start()
    
    @tasks.loop(seconds=30)
    async def combat_monitor(self):
        """每30秒检查战斗状态"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{self.api_base}/api/v1/combat/current") as resp:
                    if resp.status == 200:
                        combat = await resp.json()
                        if combat:
                            await self.send_combat_update(combat)
        except Exception as e:
            print(f"监控失败: {e}")
    
    async def send_combat_update(self, combat_data):
        """发送战斗更新到指定频道"""
        channel = self.get_channel(YOUR_CHANNEL_ID)  # 替换为实际频道ID
        if channel:
            embed = discord.Embed(title="战斗进行中", color=0x00ff00)
            embed.add_field(name="区域", value=combat_data.get('zone_name', 'Unknown'))
            embed.add_field(name="BOSS", value=combat_data.get('boss_name', 'Unknown'))
            embed.add_field(name="持续时间", value=f"{combat_data.get('duration', 0):.0f}秒")
            await channel.send(embed=embed)
    
    @commands.command(name='dps')
    async def show_dps(self, ctx):
        """显示当前DPS统计"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{self.api_base}/api/v1/combat/live/stats") as resp:
                    if resp.status == 200:
                        stats = await resp.json()
                        
                        if stats:
                            embed = discord.Embed(title="实时DPS统计", color=0x0099ff)
                            
                            # 按DPS排序
                            sorted_stats = sorted(stats.items(), 
                                                key=lambda x: x[1].get('dps', 0), 
                                                reverse=True)
                            
                            for i, (player, data) in enumerate(sorted_stats[:10]):
                                dps = data.get('dps', 0)
                                damage = data.get('total_damage', 0)
                                embed.add_field(
                                    name=f"{i+1}. {player}", 
                                    value=f"DPS: {dps:.1f}\n总伤害: {damage:,}", 
                                    inline=True
                                )
                            
                            await ctx.send(embed=embed)
                        else:
                            await ctx.send("当前没有战斗数据")
        except Exception as e:
            await ctx.send(f"获取数据失败: {e}")

# 启动机器人
bot = FFXIVBot()
bot.run('YOUR_BOT_TOKEN')  # 替换为实际的机器人token
```

## 🔧 测试和调试

### 1. 注入测试数据

```python
import requests
import random
import time

def inject_test_damage():
    """注入测试伤害数据"""
    players = ["战士坦克", "白魔法师", "黑魔法师", "龙骑士"]
    actions = ["重劈", "治疗", "火球术", "跳跃"]
    
    for i in range(10):
        damage_data = {
            'source_id': f'player_{random.randint(1, 4)}',
            'source_name': random.choice(players),
            'target_id': 'boss_001',
            'target_name': '石卫塔',
            'action_id': '8D',
            'damage': random.randint(800, 2500),
            'is_critical': random.random() < 0.25,
            'is_direct_hit': random.random() < 0.25
        }
        
        response = requests.post(
            "http://localhost:8000/api/v1/inject/damage",
            json=damage_data
        )
        print(f"注入数据 {i+1}: {response.status_code}")
        time.sleep(1)

if __name__ == "__main__":
    inject_test_damage()
```

### 2. 前端测试页面

直接打开 [`frontend_example.html`](file://e:\code\myact\FFXIV_ACT_Plugin\api_design\frontend_example.html) 文件，您将看到：
- 实时DPS统计
- 战斗事件流
- 连接状态指示
- 测试数据注入按钮

## 🚨 常见问题

### 1. API服务无法启动
```bash
# 检查端口占用
netstat -ano | findstr :8000

# 使用其他端口
uvicorn main:app --port 8001
```

### 2. WebSocket连接失败
- 确保防火墙允许8000端口
- 检查网络代理设置
- 尝试使用 `127.0.0.1` 替代 `localhost`

### 3. 数据解析错误
- 检查 Definitions 和 Overrides 文件路径
- 验证JSON文件格式
- 查看控制台错误日志

## 📈 性能优化

### 1. 生产环境部署
```bash
# 使用gunicorn (推荐)
pip install gunicorn
gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker

# 使用nginx反向代理
# nginx.conf 配置示例
server {
    listen 80;
    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    location /ws/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

### 2. 数据库集成
```python
# 添加PostgreSQL支持
pip install asyncpg sqlalchemy

# 在main.py中添加数据库配置
from sqlalchemy.ext.asyncio import create_async_engine

DATABASE_URL = "postgresql+asyncpg://user:password@localhost/ffxiv_combat"
engine = create_async_engine(DATABASE_URL)
```

现在您可以根据这个指南开始使用FFXIV战斗数据API了！从简单的数据查询到复杂的实时监控应用，这个API都能满足您的需求。

需要我详细解释某个特定部分，或者帮您解决具体的集成问题吗？
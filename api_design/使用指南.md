# FFXIVæˆ˜æ–—æ•°æ®API ä½¿ç”¨æŒ‡å—

## ğŸš€ å¿«é€Ÿå¼€å§‹

### ç¬¬ä¸€æ­¥ï¼šç¯å¢ƒå‡†å¤‡

1. **ç¡®ä¿Pythonç¯å¢ƒ**
   - Python 3.8 æˆ–æ›´é«˜ç‰ˆæœ¬
   - æ¨èä½¿ç”¨è™šæ‹Ÿç¯å¢ƒ

```bash
# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv ffxiv_api_env

# æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ (Windows)
ffxiv_api_env\Scripts\activate

# æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ (Linux/Mac)
source ffxiv_api_env/bin/activate
```

2. **å®‰è£…ä¾èµ–**
```bash
# è¿›å…¥é¡¹ç›®ç›®å½•
cd e:\code\myact\FFXIV_ACT_Plugin\api_design

# å®‰è£…æ‰€éœ€åŒ…
pip install -r requirements.txt
```

### ç¬¬äºŒæ­¥ï¼šå¯åŠ¨APIæœåŠ¡

```bash
# æ–¹å¼1ï¼šç›´æ¥è¿è¡Œ
python main.py

# æ–¹å¼2ï¼šä½¿ç”¨uvicorn
uvicorn main:app --host 0.0.0.0 --port 8000 --reload

# æ–¹å¼3ï¼šåå°è¿è¡Œ
nohup python main.py &
```

æœåŠ¡å¯åŠ¨åï¼Œæ‚¨ä¼šçœ‹åˆ°ï¼š
```
INFO:     Started server process [12345]
INFO:     Waiting for application startup.
INFO:     FFXIV Combat Parser åˆå§‹åŒ–æˆåŠŸ
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000
```

### ç¬¬ä¸‰æ­¥ï¼šéªŒè¯æœåŠ¡

æ‰“å¼€æµè§ˆå™¨è®¿é—®ï¼š
- **APIæ–‡æ¡£**: http://localhost:8000/docs
- **å¥åº·æ£€æŸ¥**: http://localhost:8000/health
- **APIçŠ¶æ€**: http://localhost:8000/api/v1/status

## ğŸ“Š åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹

### 1. æŸ¥çœ‹APIæ–‡æ¡£
è®¿é—® http://localhost:8000/docs æŸ¥çœ‹å®Œæ•´çš„APIæ¥å£æ–‡æ¡£ï¼ŒåŒ…æ‹¬ï¼š
- æ‰€æœ‰æ¥å£åˆ—è¡¨
- å‚æ•°è¯´æ˜
- å“åº”æ ¼å¼
- åœ¨çº¿æµ‹è¯•åŠŸèƒ½

### 2. Pythonå®¢æˆ·ç«¯ä½¿ç”¨

```python
import requests
import json
import websocket
import threading

# APIåŸºç¡€åœ°å€
API_BASE = "http://localhost:8000"

# è·å–å½“å‰æˆ˜æ–—ä¿¡æ¯
def get_current_combat():
    response = requests.get(f"{API_BASE}/api/v1/combat/current")
    if response.status_code == 200:
        return response.json()
    return None

# è·å–å®æ—¶DPSç»Ÿè®¡
def get_live_stats():
    response = requests.get(f"{API_BASE}/api/v1/combat/live/stats")
    return response.json()

# è·å–æœ€è¿‘çš„æˆ˜æ–—äº‹ä»¶
def get_recent_events(limit=20):
    response = requests.get(f"{API_BASE}/api/v1/combat/live/events?limit={limit}")
    return response.json()

# æœç´¢æŠ€èƒ½
def search_actions(keyword):
    response = requests.get(f"{API_BASE}/api/v1/search/actions?keyword={keyword}")
    return response.json()

# WebSocketç›‘å¬å®æ—¶æ•°æ®
def listen_live_events():
    def on_message(ws, message):
        data = json.loads(message)
        print(f"æ”¶åˆ°äº‹ä»¶: {data['type']}")
        
        if data['type'] == 'damage':
            print(f"  {data['source_name']} å¯¹ {data['target_name']} é€ æˆ {data['damage']} ä¼¤å®³")
        elif data['type'] == 'heal':
            print(f"  {data['source_name']} æ²»ç–—äº† {data['target_name']} {data['heal_amount']} ç‚¹")

    def on_error(ws, error):
        print(f"WebSocketé”™è¯¯: {error}")

    def on_close(ws, close_status_code, close_msg):
        print("WebSocketè¿æ¥å…³é—­")

    ws = websocket.WebSocketApp("ws://localhost:8000/ws/live",
                                on_message=on_message,
                                on_error=on_error,
                                on_close=on_close)
    ws.run_forever()

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # è·å–å½“å‰æˆ˜æ–—
    combat = get_current_combat()
    print(f"å½“å‰æˆ˜æ–—: {combat}")
    
    # è·å–å®æ—¶ç»Ÿè®¡
    stats = get_live_stats()
    print(f"å®æ—¶ç»Ÿè®¡: {stats}")
    
    # æœç´¢æŠ€èƒ½
    fire_skills = search_actions("fire")
    print(f"ç«ç³»æŠ€èƒ½: {fire_skills}")
    
    # å¯åŠ¨WebSocketç›‘å¬ (åœ¨å•ç‹¬çº¿ç¨‹ä¸­)
    ws_thread = threading.Thread(target=listen_live_events)
    ws_thread.daemon = True
    ws_thread.start()
    
    # ä¸»ç¨‹åºç»§ç»­è¿è¡Œ...
    input("æŒ‰å›è½¦é”®é€€å‡º...")
```

### 3. JavaScript/Webä½¿ç”¨

```html
<!DOCTYPE html>
<html>
<head>
    <title>FFXIVæ•°æ®ç›‘æ§</title>
</head>
<body>
    <div id="stats"></div>
    <div id="events"></div>

    <script>
        // è·å–å®æ—¶ç»Ÿè®¡
        async function fetchStats() {
            try {
                const response = await fetch('/api/v1/combat/live/stats');
                const stats = await response.json();
                
                document.getElementById('stats').innerHTML = 
                    '<h3>å®æ—¶DPSç»Ÿè®¡</h3>' +
                    Object.entries(stats).map(([player, data]) => 
                        `<p>${player}: ${Math.round(data.dps || 0)} DPS</p>`
                    ).join('');
            } catch (error) {
                console.error('è·å–ç»Ÿè®¡å¤±è´¥:', error);
            }
        }

        // WebSocketå®æ—¶äº‹ä»¶
        const ws = new WebSocket('ws://localhost:8000/ws/live');
        const eventsList = [];

        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            eventsList.unshift(data);
            eventsList.splice(10); // åªä¿ç•™æœ€è¿‘10ä¸ªäº‹ä»¶
            
            updateEventsDisplay();
        };

        function updateEventsDisplay() {
            const eventsHtml = eventsList.map(event => {
                if (event.type === 'damage') {
                    return `<p style="color: red;">${event.source_name} â†’ ${event.target_name}: ${event.damage} ä¼¤å®³</p>`;
                } else if (event.type === 'heal') {
                    return `<p style="color: green;">${event.source_name} â†’ ${event.target_name}: ${event.heal_amount} æ²»ç–—</p>`;
                }
                return '';
            }).join('');
            
            document.getElementById('events').innerHTML = '<h3>å®æ—¶äº‹ä»¶</h3>' + eventsHtml;
        }

        // å®šæœŸæ›´æ–°ç»Ÿè®¡
        setInterval(fetchStats, 1000);
        fetchStats(); // åˆå§‹åŠ è½½
    </script>
</body>
</html>
```

## ğŸ® å®é™…åº”ç”¨åœºæ™¯

### 1. å›¢é˜ŸDPSç›‘æ§é¢æ¿

```python
import tkinter as tk
from tkinter import ttk
import requests
import threading
import time

class DPSMonitor:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("FFXIV DPSç›‘æ§")
        self.root.geometry("600x400")
        
        # åˆ›å»ºè¡¨æ ¼
        self.tree = ttk.Treeview(self.root, columns=('DPS', 'Damage', 'Hits'), show='tree headings')
        self.tree.heading('#0', text='ç©å®¶åç§°')
        self.tree.heading('DPS', text='DPS')
        self.tree.heading('Damage', text='æ€»ä¼¤å®³')
        self.tree.heading('Hits', text='å‘½ä¸­æ¬¡æ•°')
        self.tree.pack(fill=tk.BOTH, expand=True)
        
        # å¯åŠ¨æ•°æ®æ›´æ–°çº¿ç¨‹
        self.update_thread = threading.Thread(target=self.update_data, daemon=True)
        self.update_thread.start()
    
    def update_data(self):
        while True:
            try:
                response = requests.get("http://localhost:8000/api/v1/combat/live/stats")
                if response.status_code == 200:
                    stats = response.json()
                    self.root.after(0, self.update_ui, stats)
            except Exception as e:
                print(f"æ›´æ–°æ•°æ®å¤±è´¥: {e}")
            
            time.sleep(1)
    
    def update_ui(self, stats):
        # æ¸…ç©ºç°æœ‰æ•°æ®
        for item in self.tree.get_children():
            self.tree.delete(item)
        
        # æ·»åŠ æ–°æ•°æ®ï¼ŒæŒ‰DPSæ’åº
        sorted_stats = sorted(stats.items(), key=lambda x: x[1].get('dps', 0), reverse=True)
        
        for player_id, data in sorted_stats:
            self.tree.insert('', 'end', text=player_id, values=(
                f"{data.get('dps', 0):.1f}",
                f"{data.get('total_damage', 0):,}",
                f"{data.get('hit_count', 0)}"
            ))
    
    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    monitor = DPSMonitor()
    monitor.run()
```

### 2. Discordæœºå™¨äººé›†æˆ

```python
import discord
from discord.ext import commands, tasks
import aiohttp
import asyncio

class FFXIVBot(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix='!', intents=discord.Intents.default())
        self.api_base = "http://localhost:8000"
        
    async def setup_hook(self):
        self.combat_monitor.start()
    
    @tasks.loop(seconds=30)
    async def combat_monitor(self):
        """æ¯30ç§’æ£€æŸ¥æˆ˜æ–—çŠ¶æ€"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{self.api_base}/api/v1/combat/current") as resp:
                    if resp.status == 200:
                        combat = await resp.json()
                        if combat:
                            await self.send_combat_update(combat)
        except Exception as e:
            print(f"ç›‘æ§å¤±è´¥: {e}")
    
    async def send_combat_update(self, combat_data):
        """å‘é€æˆ˜æ–—æ›´æ–°åˆ°æŒ‡å®šé¢‘é“"""
        channel = self.get_channel(YOUR_CHANNEL_ID)  # æ›¿æ¢ä¸ºå®é™…é¢‘é“ID
        if channel:
            embed = discord.Embed(title="æˆ˜æ–—è¿›è¡Œä¸­", color=0x00ff00)
            embed.add_field(name="åŒºåŸŸ", value=combat_data.get('zone_name', 'Unknown'))
            embed.add_field(name="BOSS", value=combat_data.get('boss_name', 'Unknown'))
            embed.add_field(name="æŒç»­æ—¶é—´", value=f"{combat_data.get('duration', 0):.0f}ç§’")
            await channel.send(embed=embed)
    
    @commands.command(name='dps')
    async def show_dps(self, ctx):
        """æ˜¾ç¤ºå½“å‰DPSç»Ÿè®¡"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{self.api_base}/api/v1/combat/live/stats") as resp:
                    if resp.status == 200:
                        stats = await resp.json()
                        
                        if stats:
                            embed = discord.Embed(title="å®æ—¶DPSç»Ÿè®¡", color=0x0099ff)
                            
                            # æŒ‰DPSæ’åº
                            sorted_stats = sorted(stats.items(), 
                                                key=lambda x: x[1].get('dps', 0), 
                                                reverse=True)
                            
                            for i, (player, data) in enumerate(sorted_stats[:10]):
                                dps = data.get('dps', 0)
                                damage = data.get('total_damage', 0)
                                embed.add_field(
                                    name=f"{i+1}. {player}", 
                                    value=f"DPS: {dps:.1f}\næ€»ä¼¤å®³: {damage:,}", 
                                    inline=True
                                )
                            
                            await ctx.send(embed=embed)
                        else:
                            await ctx.send("å½“å‰æ²¡æœ‰æˆ˜æ–—æ•°æ®")
        except Exception as e:
            await ctx.send(f"è·å–æ•°æ®å¤±è´¥: {e}")

# å¯åŠ¨æœºå™¨äºº
bot = FFXIVBot()
bot.run('YOUR_BOT_TOKEN')  # æ›¿æ¢ä¸ºå®é™…çš„æœºå™¨äººtoken
```

## ğŸ”§ æµ‹è¯•å’Œè°ƒè¯•

### 1. æ³¨å…¥æµ‹è¯•æ•°æ®

```python
import requests
import random
import time

def inject_test_damage():
    """æ³¨å…¥æµ‹è¯•ä¼¤å®³æ•°æ®"""
    players = ["æˆ˜å£«å¦å…‹", "ç™½é­”æ³•å¸ˆ", "é»‘é­”æ³•å¸ˆ", "é¾™éª‘å£«"]
    actions = ["é‡åŠˆ", "æ²»ç–—", "ç«çƒæœ¯", "è·³è·ƒ"]
    
    for i in range(10):
        damage_data = {
            'source_id': f'player_{random.randint(1, 4)}',
            'source_name': random.choice(players),
            'target_id': 'boss_001',
            'target_name': 'çŸ³å«å¡”',
            'action_id': '8D',
            'damage': random.randint(800, 2500),
            'is_critical': random.random() < 0.25,
            'is_direct_hit': random.random() < 0.25
        }
        
        response = requests.post(
            "http://localhost:8000/api/v1/inject/damage",
            json=damage_data
        )
        print(f"æ³¨å…¥æ•°æ® {i+1}: {response.status_code}")
        time.sleep(1)

if __name__ == "__main__":
    inject_test_damage()
```

### 2. å‰ç«¯æµ‹è¯•é¡µé¢

ç›´æ¥æ‰“å¼€ [`frontend_example.html`](file://e:\code\myact\FFXIV_ACT_Plugin\api_design\frontend_example.html) æ–‡ä»¶ï¼Œæ‚¨å°†çœ‹åˆ°ï¼š
- å®æ—¶DPSç»Ÿè®¡
- æˆ˜æ–—äº‹ä»¶æµ
- è¿æ¥çŠ¶æ€æŒ‡ç¤º
- æµ‹è¯•æ•°æ®æ³¨å…¥æŒ‰é’®

## ğŸš¨ å¸¸è§é—®é¢˜

### 1. APIæœåŠ¡æ— æ³•å¯åŠ¨
```bash
# æ£€æŸ¥ç«¯å£å ç”¨
netstat -ano | findstr :8000

# ä½¿ç”¨å…¶ä»–ç«¯å£
uvicorn main:app --port 8001
```

### 2. WebSocketè¿æ¥å¤±è´¥
- ç¡®ä¿é˜²ç«å¢™å…è®¸8000ç«¯å£
- æ£€æŸ¥ç½‘ç»œä»£ç†è®¾ç½®
- å°è¯•ä½¿ç”¨ `127.0.0.1` æ›¿ä»£ `localhost`

### 3. æ•°æ®è§£æé”™è¯¯
- æ£€æŸ¥ Definitions å’Œ Overrides æ–‡ä»¶è·¯å¾„
- éªŒè¯JSONæ–‡ä»¶æ ¼å¼
- æŸ¥çœ‹æ§åˆ¶å°é”™è¯¯æ—¥å¿—

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### 1. ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
```bash
# ä½¿ç”¨gunicorn (æ¨è)
pip install gunicorn
gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker

# ä½¿ç”¨nginxåå‘ä»£ç†
# nginx.conf é…ç½®ç¤ºä¾‹
server {
    listen 80;
    location / {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    location /ws/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

### 2. æ•°æ®åº“é›†æˆ
```python
# æ·»åŠ PostgreSQLæ”¯æŒ
pip install asyncpg sqlalchemy

# åœ¨main.pyä¸­æ·»åŠ æ•°æ®åº“é…ç½®
from sqlalchemy.ext.asyncio import create_async_engine

DATABASE_URL = "postgresql+asyncpg://user:password@localhost/ffxiv_combat"
engine = create_async_engine(DATABASE_URL)
```

ç°åœ¨æ‚¨å¯ä»¥æ ¹æ®è¿™ä¸ªæŒ‡å—å¼€å§‹ä½¿ç”¨FFXIVæˆ˜æ–—æ•°æ®APIäº†ï¼ä»ç®€å•çš„æ•°æ®æŸ¥è¯¢åˆ°å¤æ‚çš„å®æ—¶ç›‘æ§åº”ç”¨ï¼Œè¿™ä¸ªAPIéƒ½èƒ½æ»¡è¶³æ‚¨çš„éœ€æ±‚ã€‚

éœ€è¦æˆ‘è¯¦ç»†è§£é‡ŠæŸä¸ªç‰¹å®šéƒ¨åˆ†ï¼Œæˆ–è€…å¸®æ‚¨è§£å†³å…·ä½“çš„é›†æˆé—®é¢˜å—ï¼Ÿ